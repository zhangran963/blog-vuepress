---
title: '任务队列'
---

## 总结的示例

![](https://ran-1303246897.cos.ap-guangzhou.myqcloud.com/www/markdown/20200102132002.jpeg)

* 从 start 处开始; 
* 循环执行(每进行一次循环操作称为tick); 
* 除同步执行外,  `process.nextTick` 优先级最高, 高于 `Promise`; 
* 执行完: 1个宏任务+(所有)微任务后, 执行1次 UI渲染; 

---

## 示例 1

```js
const fs = require('fs');

fs.readFile(__filename, () => {
  // I/O操作

  setTimeout(() => {
    // 阶段1
    console.log('* setTimeout');
    setImmediate(() => {
      // 阶段3
      console.log('* setImmediate');
    });
    // 阶段1后的Tick
    // 优先级低
    Promise.resolve().then(_ => {
      console.log('* promise');
    });
    // 优先级高
    process.nextTick(() => {
      console.log('* nextTick');
    });
  }, 0);
});
```

![](https://ran-1303246897.cos.ap-guangzhou.myqcloud.com/www/markdown/20200102132630.png)

---

## 示例 2

* 执行 Tick 任务时, 需要执行完所有 Tick 任务

```js
setImmediate(() => {
  console.log(1);
  setTimeout(() => {
    console.log(2);
  }, 100);
  setImmediate(() => {
    console.log(3);
  });
  process.nextTick(() => {
    // nextTick型异步, 仅次于同步
    // 执行此nextTick后, 执行完所有Tick任务, 优于即将执行的setImmediate
    Promise.resolve('加塞的Tick').then(console.log);
    console.log(4);
  });
});
process.nextTick(() => {
  // nextTick型异步, 仅次于同步
  console.log(5);
  setTimeout(() => {
    console.log(6);
  }, 100);
  setImmediate(() => {
    console.log(7);
  });
  process.nextTick(() => {
    // nextTick型异步, 仅次于同步
    console.log(8);
  });
});
console.log(9); // 同步, 最先打印
```

![](https://ran-1303246897.cos.ap-guangzhou.myqcloud.com/www/markdown/20200102133739.png)

---

```js
setTimeout(() => console.log('a'), 0);
var p = new Promise(resolve => {
  console.log('b');
  resolve();
});
p.then(() => console.log('c'));
p.then(() => console.log('d'));
console.log('e');
// 结果：b e c d a
```

* 优先级：`promise. Trick()` > `promise.then()` > `setTimeout(callback, 0)` > `setImmediate(callback)`; 

## Promise 和 async await 的区别

* 用 Promise 表示 Promise
  + Promise 创建时, 同步优先级
  + async(Promise 优先级一样) 创建时, 需要执行函数; 

```js
new Promise(function async1(res, rej) {
  console.log('* a');
  new Promise(function async2(subRes) {
    console.log('* c');
  });
  res();
}).then(_ => {
  console.log('* b');
});

console.log('d');
setTimeout(function() {
  console.log('e');
}, 0);
new Promise(function(resolve) {
  console.log('f');
  resolve();
}).then(function() {
  console.log('g');
});
console.log('h');

/* a c d f h b g e */
```

* 用 async 表示 Promise
  + async(Promise 优先级一样) 创建时, 需要执行函数; 

```js
async function async1() {
  console.log('a');
  await async2(); //async2()属于 new Promise部分, await及以后属于 .then 部分
  console.log('b');
}
async function async2() {
  console.log('c');
}
console.log('d');
setTimeout(function() {
  console.log('e');
}, 0);
async1();
new Promise(function(resolve) {
  console.log('f');
  resolve();
}).then(function() {
  console.log('g');
});
console.log('h');

// 输出:d a c f h b g e
```

* async 类似 new Promise; 
* await 及之后的函数类似.then(注: await 的值属于 new Promise 部分, 先执行); 
* `new Promise` 里的内容 与 `console.log` 平级; 
* `async function xxx(){}` , 此语句不会立即执行, 只用到 `xxx()` 时才执行; 
* await 产生的 then 比 promise 产生的 then 慢一点; 

```js
setTimeout(function() {
  console.log(1);
}, 1000);

new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 1000000; i++) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function() {
  console.log(4);
});

console.log(5);

// 顺序:2>3>5>4>1
```

## `new Promise()` 中, resolve 之后的函数也会执行

```js
new Promise(res => {
  console.log('before');
  for (let i = 0; i < 1000; i++) {
    if (i === 999) {
      console.log('sended');
      res('data');
    }
  }
  console.log('after');
}).then(res => {
  console.log(res);
});
```

![](https://ran-1303246897.cos.ap-guangzhou.myqcloud.com/www/markdown/20200102110925.png)

> setTimeout 它会在延迟时间结束后分配一个新的 task 至 event loop 中，而不是立即执行，所以 setTimeout 的回调函数会等待前面的 task 都执行结束后再运行。

## microtask(微任务)

* 和 task 任务队列 相互独立的队列; 
* 每执行完一个 task 就会执行 microtask 队列 ; 
* microtask 队列 产生的 microtask 添加到此队列的尾部; 
* microtask 队列的任务类型包括 MutationObserver 和 Promise 的回调函数; 

## macrotask(task) 和 microtask

过程:

1. JavaScript 引擎首先从 macrotask queue 中取出第一个任务;
2. 执行完毕后，将 microtask queue 中的所有任务取出，按顺序全部执行(新的 microtask 往尾部排)；
3. 更新render
4. 然后再从 macrotask queue 中取下一个(执行下一个 task);
5. 执行完毕后，再次将 microtask queue 中的全部取出(再次执行全部 microtask)；
6. 循环往复，直到两个 queue 中的任务都取完。

## 类型:

### macrotasks(宏任务): 

* script, setTimeout, setInterval, setImmediate, I/O, UI rendering, 事件

### microtasks(微任务): 

* process.nextTick, Promise.then, MutationObserver

### 优先级

* (浏览器)promise.then > setImmediate > setTimeout; 
* (Node)process.nextTick > promise.then > setTimeout(, 0) > setImmediate; 

## UI渲染

* 根据"HTML Standard"，一轮事件循环执行结束之后，下轮事件循环执行之前开始进行 UI render。
* 当前macro-task任务执行完 + 完成所有的micro-task任务后 => 开始执行UI渲染。
* UI render完毕之后接着下一轮循环。

---

## 函数的继承

```js
Function.prototype.a = 'a';
Object.prototype.b = 'b';

function Person() {}
var p = new Person();
console.log('p.a: ' + p.a); // p.a: undefined
console.log('p.b: ' + p.b); // p.b: b
```

```js
/* 自定义的函数 */
function Person() {}

/* 前面参数是参数, 最后的参数是函数体 */
let createdFunc = (func = new Function('arr', 'return arr.reduce((cur, prev) => {return cur+prev }, 0)'));
```

* 自定义的函数 和 Function, 平级; 
* 有等式: `Person.prototype.__proto__ === Function.prototype.__proto__ === Object.prototype`

三个等效的闭包; 

```js
for (var i = 0; i < 10; i++) {
  void(function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 10);
  })(i);
}

for (var i = 0; i < 10; i++) {
  var func = function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 10);
  };
  func(i);
}

for (var i = 0; i < 10; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 10);
  })(i);
}
```
